name: Deploy to EKS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

# Prevent concurrent deployments
concurrency:
  group: terraform-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: ap-south-1
  TERRAFORM_VERSION: 1.6.6
  CLUSTER_NAME: infraops-eks-prod

jobs:
  terraform:
    name: Terraform Infrastructure
    runs-on: ubuntu-latest
    environment: production
    outputs:
      cluster_name: ${{ steps.tf_output.outputs.cluster_name }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify AWS identity
      run: aws sts get-caller-identity

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false

    - name: Terraform Format Check
      working-directory: envs/prod
      run: terraform fmt -check -recursive
      continue-on-error: true

    - name: Terraform Init
      working-directory: envs/prod
      run: |
        terraform init -input=false -reconfigure

    - name: Check for existing state locks
      id: check_lock
      working-directory: envs/prod
      continue-on-error: true
      run: |
        # Try to refresh state to check for locks
        terraform plan -input=false -detailed-exitcode \
          -var="aws_region=${{ env.AWS_REGION }}" \
          -out=/dev/null 2>&1 | tee plan_output.txt || true
        
        if grep -q "Error acquiring the state lock" plan_output.txt; then
          echo "lock_exists=true" >> $GITHUB_OUTPUT
          LOCK_ID=$(grep -oP "ID:\s+\K[a-f0-9-]+" plan_output.txt | head -1)
          echo "lock_id=$LOCK_ID" >> $GITHUB_OUTPUT
        fi
      env:
        TF_VAR_aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_db_password: ${{ secrets.TF_VAR_DB_PASSWORD }}

    - name: Force unlock stale lock
      if: steps.check_lock.outputs.lock_exists == 'true'
      working-directory: envs/prod
      run: |
        echo "⚠️ Stale lock detected, forcing unlock..."
        terraform force-unlock -force ${{ steps.check_lock.outputs.lock_id }}
        echo "✅ Lock released" \
          -backend-config="bucket=infraops-tfstate-chandruuniqueid" \
          -backend-config="key=prod/terraform.tfstate" \
          -backend-config="region=ap-south-1" \
          -backend-config="encrypt=true" \
          -backend-config="dynamodb_table=terraform-locks"

    - name: Terraform Validate
      working-directory: envs/prod
      run: terraform validate

    - name: Terraform Plan
      working-directory: envs/prod
      run: |
        terraform plan -input=false -out=tfplan \
          -var="aws_region=${{ env.AWS_REGION }}"
      env:
        TF_VAR_aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_db_password: ${{ secrets.TF_VAR_DB_PASSWORD }}

    - name: Terraform Apply
      working-directory: envs/prod
      run: |
        echo "Terraform apply started at: $(date)"
        terraform apply -auto-approve -input=false tfplan
        echo "Terraform apply completed at: $(date)"
      env:
        TF_VAR_db_password: ${{ secrets.TF_VAR_DB_PASSWORD }}

    - name: Get Terraform Outputs
      id: tf_output
      working-directory: envs/prod
      run: |
        CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "${{ env.CLUSTER_NAME }}")
        echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: terraform
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: 'v1.28.0'

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig \
          --name ${{ needs.terraform.outputs.cluster_name }} \
          --region ${{ env.AWS_REGION }}

    - name: Verify cluster connection
      run: |
        kubectl cluster-info
        kubectl get nodes

    - name: Create namespace if not exists
      run: |
        kubectl create namespace production --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy application
      run: |
        kubectl apply -f app/k8s/deployment.yaml -n production
        kubectl apply -f app/k8s/service.yaml -n production

    - name: Wait for deployment rollout
      run: |
        kubectl rollout status deployment/$(yq eval '.metadata.name' app/k8s/deployment.yaml) \
          -n production --timeout=5m

    - name: Verify deployment
      run: |
        kubectl get pods -n production
        kubectl get svc -n production

    - name: Run smoke tests
      run: |
        echo "Running smoke tests..."
        SERVICE_URL=$(kubectl get svc -n production -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}')
        if [ -n "$SERVICE_URL" ]; then
          echo "Service URL: $SERVICE_URL"
          # Add curl health check or wait for LB
        fi

  notify:
    name: Notify deployment status
    runs-on: ubuntu-latest
    needs: [terraform, deploy]
    if: always()
    
    steps:
    - name: Send notification
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "✅ Deployment successful"
        else
          echo "❌ Deployment failed"
        fi
        # Add Slack/email notification here

