name: Deploy to EKS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: ap-south-1
  TERRAFORM_VERSION: 1.6.6
  CLUSTER_NAME: titan-cluster

jobs:
  terraform:
    name: Terraform Infrastructure
    runs-on: ubuntu-latest
    environment: production
    outputs:
      cluster_name: ${{ steps.tf_output.outputs.cluster_name }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify AWS identity
      run: aws sts get-caller-identity

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false

    - name: Terraform Format Check
      working-directory: envs/prod
      run: terraform fmt -check -recursive
      continue-on-error: true

    - name: Terraform Init
      working-directory: envs/prod
      run: |
        terraform init -input=false \
          -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
          -backend-config="key=prod/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}"

    - name: Terraform Validate
      working-directory: envs/prod
      run: terraform validate

    - name: Terraform Plan
      working-directory: envs/prod
      run: |
        terraform plan -input=false -out=tfplan \
          -var="aws_region=${{ env.AWS_REGION }}"
      env:
        TF_VAR_aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Terraform Apply
      working-directory: envs/prod
      run: |
        echo "Terraform apply started at: $(date)"
        terraform apply -auto-approve -input=false tfplan
        echo "Terraform apply completed at: $(date)"

    - name: Get Terraform Outputs
      id: tf_output
      working-directory: envs/prod
      run: |
        CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "${{ env.CLUSTER_NAME }}")
        echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: terraform
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: 'v1.28.0'

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig \
          --name ${{ needs.terraform.outputs.cluster_name }} \
          --region ${{ env.AWS_REGION }}

    - name: Verify cluster connection
      run: |
        kubectl cluster-info
        kubectl get nodes

    - name: Create namespace if not exists
      run: |
        kubectl create namespace production --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy application
      run: |
        kubectl apply -f app/deployment.yaml -n production
        kubectl apply -f app/service.yaml -n production

    - name: Wait for deployment rollout
      run: |
        kubectl rollout status deployment/$(yq eval '.metadata.name' app/deployment.yaml) \
          -n production --timeout=5m

    - name: Verify deployment
      run: |
        kubectl get pods -n production
        kubectl get svc -n production

    - name: Run smoke tests
      run: |
        echo "Running smoke tests..."
        SERVICE_URL=$(kubectl get svc -n production -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}')
        if [ -n "$SERVICE_URL" ]; then
          echo "Service URL: $SERVICE_URL"
          # Add curl health check or wait for LB
        fi

  notify:
    name: Notify deployment status
    runs-on: ubuntu-latest
    needs: [terraform, deploy]
    if: always()
    
    steps:
    - name: Send notification
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "✅ Deployment successful"
        else
          echo "❌ Deployment failed"
        fi
        # Add Slack/email notification here